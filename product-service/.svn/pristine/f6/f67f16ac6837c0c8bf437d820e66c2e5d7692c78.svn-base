package com.yikuyi.product.goods.manager;

import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Future;
import java.util.stream.Collectors;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.bson.Document;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.AsyncResult;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.alibaba.fastjson.JSONObject;
import com.mongodb.client.MongoCursor;
import com.yikuyi.party.PartyClientBuilder;
import com.yikuyi.party.group.vo.PartyGroupVo;
import com.yikuyi.party.model.Party;
import com.yikuyi.party.resource.PartyGroupClient;
import com.yikuyi.party.vo.PartyVo;
import com.yikuyi.product.goods.dao.ProductClient;
import com.yikuyi.product.goods.dao.ProductRepository;
import com.yikuyi.product.model.Product;
/**
 * 商品
 * 
 * @author zr.wujiajun
 * @2016年12月7日
 */
@Service
@Transactional
public class ProductAsyncManager {
	private static final Logger logger = LoggerFactory.getLogger(ProductAsyncManager.class);
	
	/**
	 * 更新时间的属性名
	 */
	public static final String UPDATED_TIME_MILLIS_FIELD_NAME = "updatedTimeMillis";
	
	
	 @Autowired
    private MongoTemplate mongoTemplate;
	 
	 @Autowired
	private PartyClientBuilder partyClientBuilder;
	 
	 @Autowired
	private ProductRepository productRepository;
	 
	 @Autowired
	private ProductClient pc;
	
	/**
	 * 获取所有的供应商
	 * 
	 * @since 2017年5月19日
	 * @author zr.wenjiao@yikuyi.com
	 */
	public List<PartyVo> getVendorInfo(){
		List<PartyVo> vendorList = new ArrayList<>();
		try{
			PartyGroupClient client = partyClientBuilder.partyGroupClient();
			PartyGroupVo partyGroupVo = new PartyGroupVo();
			partyGroupVo.setStatus(Party.PartyStatus.PARTY_ENABLED);
			partyGroupVo.setRoleType("SUPPLIER");
			long time = System.currentTimeMillis();
			List<PartyVo> venderInfoList = client.partyGroups(partyGroupVo);
			logger.info("查询供应商完成,耗时:{}",(System.currentTimeMillis()-time));
			if(CollectionUtils.isNotEmpty(venderInfoList)){
				return venderInfoList;
			}
		}catch(Exception e){
		    logger.error("getVendorInfo error",e);
		}
		return vendorList;
	}
	
	/**
	 * 一个月以外的非标准库存数据从正式表物理清除，写入到备份表里面
	 * 此服务jekins每天定时调度一次
	 * @since 2017年6月5日
	 * @author zr.wanghong
	 */
	public void cleanNonStandardData(){
		logger.info("开始非标准和垃圾数据清理!");
		//DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyyMMddHHmmss");
		//String collectionName = "product_"+LocalDateTime.now().format(dateFormatter);
		String collectionName = "product_prices_expired";
		LocalDateTime time = LocalDateTime.now().withNano(0).minusMonths(1); 
		
		List<PartyVo> vendors = getVendorInfo();
		//1.筛选出需要数据清理的供应商
		ArrayList<PartyVo> waitForCleanVendors = (ArrayList<PartyVo>) vendors.stream().filter( partyVo -> {
			return "Y".equals(partyVo.getIsAutoIntegrateQty());
		}).collect(Collectors.toList());
		
		Sort sort = new Sort(Direction.ASC,"_id");
		PageRequest pageRequest = new PageRequest(0,1000,sort);
		for (PartyVo vendor : waitForCleanVendors) {
			int processedNum = 0;
			int totalCount = 0;
			//lastId用于循环分批处理
			String lastId = StringUtils.EMPTY;
			processPriceExpiredDatas(vendor, time, lastId, totalCount, processedNum, collectionName,pageRequest);
		}
		
	}
	
	@Async
	public Future<Void> processPriceExpiredDatas(PartyVo vendor ,LocalDateTime time,String lastId ,int totalCount,int processedNum,String collectionName,PageRequest pageRequest ){
		JSONObject paramJson = new JSONObject();
		Document greatThan = new Document();
		greatThan.put("$gt", lastId);
		
		paramJson.put("_id", greatThan);
		paramJson.put("vendorId", vendor.getId());
		
		JSONObject lessUpdateDate = new JSONObject();
		lessUpdateDate.put("$lt", String.valueOf(Timestamp.valueOf(time).getTime()));
		paramJson.put(UPDATED_TIME_MILLIS_FIELD_NAME, lessUpdateDate);
		/*paramJson.put("priceStatus", "expired");
		Document gtTime = new Document();
		gtTime.put("$lt", String.valueOf(Timestamp.valueOf(time).getTime()));
		paramJson.put("expiryDate",gtTime);*/
		
		Document paramDoc = new Document();
		paramDoc.put("_id", greatThan);
		paramDoc.put("vendorId", vendor.getId());
		paramDoc.put(UPDATED_TIME_MILLIS_FIELD_NAME, lessUpdateDate);
		MongoCursor<Document>  mongoCursor = pc.getCollection().find(paramDoc).limit(1000).iterator();
		
		//List<Product> products = productRepository.findListByPage(paramJson,pageRequest);
		List<Product> products = new ArrayList<>();
		if(!mongoCursor.hasNext()){
			logger.info("供应商：{}无需要清理的数据!",vendor.getDisplayName());
			return new AsyncResult<>(null);
		}else{
		 while(mongoCursor.hasNext()){
            	try {
            		Document doc = mongoCursor.next();
        			Product product = new Product();
        			product.setId(doc.getString("_id"));
        			product.setExpiryDate(doc.getString("expiryDate"));
        			product.setPriceStatus(doc.getString("priceStatus"));
        			products.add(product);
				} catch (Exception e) {
					logger.info("error is e:{}",e);
				}
            }
		}
		totalCount += products.size();
		//标记最后处理的id
		Product lastProduct = products.get(products.size()-1);
		lastId = lastProduct.getId();
		
		List<Product> waitForDeletes = new ArrayList<>();
		for (Product product : products) {
			String expiryDateStr = product.getExpiryDate();
			//过期时间超过一个月的
			if(StringUtils.isNotEmpty(expiryDateStr) && Long.valueOf(expiryDateStr) < Timestamp.valueOf(time).getTime() && "expired".equals(product.getPriceStatus())){
				waitForDeletes.add(product);
			}
		}
		
		//垃圾数据存入临时表
		waitForDeletes.stream().forEach( tempProduct -> {
			mongoTemplate.save(tempProduct,collectionName);
		});
		productRepository.delete(waitForDeletes);
		processedNum += waitForDeletes.size();
		logger.info("已清理供应商：{} 价格失效的数据：{}/{}条!",vendor.getDisplayName(),processedNum,totalCount);
		paramJson.clear();
		paramJson = null;
		waitForDeletes.clear();
		waitForDeletes = null;
		
		processPriceExpiredDatas(vendor, time, lastId, totalCount, processedNum, collectionName,pageRequest);
		return new AsyncResult<>(null);
	}
	
}